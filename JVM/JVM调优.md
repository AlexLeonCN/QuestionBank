# JVM调优
     
jdk体系组成结构图
![002](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/002.jpeg)

## 一、JVM虚拟机的作用：

java有个非常牛逼的特性，跨平台。汇编语言无法跨平台但是java可以

计算执行的其实是二进制机器码，在不同的计算机平台上二进制机器码也是不同的，因为不同的平台的指令集是不一样的

比如相同的代码在windows平台上可能是01010的机器码，但在linux平台中是11100

java就是通过jvm来实现跨平台的

下载java jdk的时候就会让你选择你需要的是哪个计算机平台的版本，jdk中的jvm就是基于不同的计算机平台特定的

总结：jvm虚拟机从软件层面屏蔽不同操作系统在底层硬件与指令上的区别

![003](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/003.jpeg)


## 二、JVM的内部构造

类装载子系统
运行时数据区（内存模型）
字节码执行引擎

![004](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/004.jpeg)

￼
当一个Math.java要执行的时候，首先javac将其编译成一个字节码文件，再使用java命令去运行它。然后jvm虚拟机就开始运行了

类装载子系统将字节码文件加载到内存区（运行时数据区），然后字节码执行器再将其运行起来

## 三、 最为重点的就是运行时数据区

(1) 堆
(2)方法区（元空间）
(3) 栈（线程栈）
(4) 本地方法栈
(5) 程序计数器

他们都占用内存空间，内存空间（运行时数据区）是用来存数据的

### 栈
  
局部变量就存放在虚拟机栈中

只要有一个线程开始运行，java虚拟机马上会给这个线程分配一个专属的线程栈

这个专属的线程栈就是从大块的虚拟机栈上面挖了一小块内存出来，用来存放这个线程的所有局部变量

所以每一个线程，都会从虚拟机栈上挖一块内存出来，存放各自线程的所有局部变量

### 栈帧
  
线程和方法是两个概念

一个线程可以运行多个方法

同一个线程上不同的方法执行时，就会从线程栈中再分配出不同的栈帧用来存放不同方法的局部变量

我们知道数据结构中的栈是FILO先进后出原则

>如下代码，开始运行时，调起线程，会给这个线程分配线程栈
>
>执行main方法，会给main方法分配栈帧存放main方法的局部变量，它的栈帧先入线程栈
>
>Main方法中调用compute方法，又会为compute方法分配栈帧存放它的局部变量，它的栈帧后入线程栈
>
>注意这些局部变量和栈帧也都是先进后出的原则
>
>当compute方法执行完后，它的栈帧首先弹出线程栈，然后main方法执行完，再后出栈。这里出栈就相当于销毁内存
> 
![005](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/005.png)

所以说， 先进后出 和我们程序及方法的嵌套调用执行顺序是一致的

> 补充
> 
> 字节码文件.class
> 
>打开之后是这样的，文件中的每一个字符串在官方文档中都有释义

![007](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/007.jpeg)

>但是这种字节码文件分子起来太过复杂，我们来分析一种可读性更高的jvm字节指令码文件
> 
>使用`javap -c Math.class > Math.txt`可以生成一种更可读的字节指令码文件并打印到txt文件中

![008](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/008.jpeg)

可以注意到上面这个代码的前面都有序号，程序计数器也会记录，以确定下一个即将执行的代码是哪一行

字节码执行引擎来修改程序计数器的这个值

### 栈帧的具体结构

分为：局部变量表，操作数栈，动态链接，方法出口

- 局部变量表：用来存放方法的局部变量
- 操作数栈：用来操作运算，操作数进行运算的临时中转空间，比如上述代码中出现(a+b)*10的运算，就会在操作数栈中进行，然后再赋值给变量并清空操作数栈
- 方法出口：用来记录此方法在调用处的位置，当方法结束后，可以找到上一个方法的调用点，好继续执行
- 动态链接：我们调用一个方法的时候，那些方法名称包括括号实际上是"符号"，比如math.compute(), "compute()"实际上是一种符号，动态链接就是根据这些东西去找到它的内存地址，从而找到对应的代码

### 程序计数器

用来记录即将执行的代码的位置

（由于线程抢占cpu分片资源，当来了更高优先级的线程会抢占，此时当前线程会被挂起，当线程重新获得cpu资源将会以程序计数器所标记的位置开始执行，以避免重复执行之前的代码。字节码执行器来修改它的值）


### 本地方法栈

本地方法是指c或c++语言实现的方法，使用native修饰

比如Thread()中有个本地方法star0()

当一段代码执行到了本地方法， 那么这个本地方法需要从本地方法栈中获取内存空间

### 方法区（元空间）

用来存放 常量 、 静态变量、  类元信息

![006](https://alexleon.oss-cn-shanghai.aliyuncs.com/markdown-pic/QuestionBank/JVM/006.png)

### 堆

- 年轻代
    - 伊甸园区（新生代）
    - 幸存区（s0,s1）
- 老年代（永久代）

当伊甸园区满了，会触发minor gc, minor gc会回收整个年轻代

幸存的对象会从伊甸园区 移动到 其中一个幸存区s0, 当再次触发minor gc， 幸存对象又会被挪到另一个空的幸存区s1, 然后s0会被清空

所以当一个对象如果一直幸存，它会在幸存区 s0 和 s1 之间反复横跳

每经历一次gc，对象的分代年龄会加1， 当加到15， 这个对象会被移动到老年代

如果幸存对象在幸存区放不下，gc后也会被直接放到老年代

当老年代放满之后，jvm会再开启一个垃圾回收线程，专门进行full gc， full gc会将年轻代和老年代都回收

当full gc之后还是没法腾出足够空间，就会内存溢出OOM, OutOfMemeryException


### 可达性分析算法

GCRoot根结点：线程栈的本地变量、静态变量、本地方法栈的变量。

将GCRoot作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余为标记的对象都是垃圾对象。

>先找到这些gcroot， 从gcroot出发去找他们引用的对象，再从对象的成员变量出发，找到它引用的其他对象，直到找到最后一个对象（它的成员变量不再引用任何对象）

>在这条链路上的所有对象，在gc的过程中都会标记为非垃圾

>其他没有被引用没有指针指向的对象，都会被当作垃圾

## 二、调优工具

